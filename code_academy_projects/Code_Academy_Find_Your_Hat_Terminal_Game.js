const prompt = require('prompt-sync')({sigint: true});

const hat = '^';
const hole = 'O';
const fieldCharacter = 'â–‘';
const pathCharacter = '*';

class Field {
    constructor(field = [[]]) {
        this._field = field;
        this._position = [0, 0]
    }

    static generateField(height, width, percentage = 0.2) {
        const field = [];
        // adds a nested array for each column of the game field
        for (let h = 0; h < height; h++) {
            field.push([]);
            // pushes elements to the nested array to fill the row of the game field 
            for (let w = 0; w < width; w++) {
                field[h].push('');
                const prob = Math.random();
                field[h][w] = prob > percentage ? fieldCharacter : hole;
            }
        }
        field[0][0] = pathCharacter;
        // set hat position; creates a new position if [0,0] is generated
        const hatPosition = [Math.floor(Math.random() * height), Math.floor(Math.random() * width)];    
        while (hatPosition === [0,0]) {
            hatPosition = [Math.floor(Math.random() * height), Math.floor(Math.random() * width)];
        }
        field[hatPosition[0]][hatPosition[1]] = hat;
        // set starting position
        const startingPosition = [Math.floor(Math.random() * height), Math.floor(Math.random() * width)];    
        while (startingPosition === [0,0]) {
            startingPosition = [Math.floor(Math.random() * height), Math.floor(Math.random() * width)];
        }
        field[startingPosition[0]][startingPosition[1]] = pathCharacter;
        field[0][0] = fieldCharacter;
        return field;
    }

    print() {
        for (let i = 0; i < this._field.length; i++) {
            console.log(this._field[i].join(""));
        };
    }

    getPosition() {
        // loops through field to find the pathCharater
        for (let counter = 0; counter < this._field.length; counter++) {
            for (let i = 0; i < this._field[counter].length; i++) {
                if (this._field[counter][i] === pathCharacter) {
                    return [counter, i];
                }
            }
        }
    }

    getMove() {
        console.log("\nWhich direction would you like to move?\n");
        console.log("L = Left \nU = Up \nR = Right \nD = Down\n")
        const move = prompt();
        return move;
    }

    // changes visited area of field to pathCharacter
    changeCharacter(position) {
        this._field[this._position[0]] [this._position[1]] = pathCharacter;
    }

    checkStatus(position) {
        if (this._field[this._position[0]][this._position[1]] === hole) {
            console.log("GAME OVER! You fell into the hole!\n");
            return true;
        } else if (this._field[this._position[0]][this._position[1]] === hat) {
            console.log("YOU WON!\n")
            return true;
        } else {
            return false;
        }
    }

    playGame() {
        this._position = this.getPosition();
        let end = false;
        while (end === false) {
            this.print();
            let move = this.getMove();
            // checks to see if the move is out of bounds, if not, changes the position
            if (move === 'l' || move === 'L') {
                if ((this._position[1] - 1) < 0) {
                    console.log("ERROR: Out of bounds! Try again.");
                } else {
                    this._position[1] = this._position[1] - 1;
                }
            }
            if (move === 'r' || move === 'R') {
                if ((this._position[1] + 1) >= this._field[0].length) {
                    console.log("ERROR: Out of bounds! Try again.");
                } else {
                    this._position[1] = this._position[1] + 1;
                }
            }
            if (move === 'u' || move === 'U') {
                if ((this._position[0] - 1) < 0) {
                    console.log("ERROR: Out of bounds! Try again.");
                } else {
                    this._position[0] = this._position[0] - 1;
                }
            }
            if (move === 'd' || move === 'D') {
                if (this._position[0] + 1 >= this._field.length) {
                    console.log("ERROR: Out of bounds! Try again.");
                } else {
                    this._position[0] = this._position[0] + 1;
                }
            }
            end = this.checkStatus(this._position);
            this.changeCharacter(this._position);
        }
    }
}

const myField = new Field(Field.generateField(10, 3));
myField.playGame();

// Challenge: Create a field validator to ensure that the field generated by Field.generateField()
// can actually be solved. (Essentially creating a version of a maze solver.)
